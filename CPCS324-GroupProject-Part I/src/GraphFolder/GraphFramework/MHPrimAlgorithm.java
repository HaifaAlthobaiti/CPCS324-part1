/*
CPCS324 Group Project | Phase1 
Alaa Algamdi ------2007156 | Section B0B 
Raghed alharbi -----2006518 | Section B0B 
Haifa Althobait-----2010445 | Section B8
Sara Alshaikh-------2005499 | Section B0B 

*/
package GraphFolder.GraphFramework;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class MHPrimAlgorithm extends MSTAlgorithm{
   
    private Map<Vertex, Edge> SmallestEdge = new HashMap<>();
    private int totalWeight = 0;
    
    public MHPrimAlgorithm(Graph graph) {
      MSTResultList = new ArrayList<>();
    }
    
    @Override
    public void findMinimumSpanningTree(Graph graph) {
        // Create a new MinHeap to store the edges, with capacity equal to the number of edges in the graph
        MinHeap minHeap = new MinHeap(graph.getEdgeNo()); 
        
        Set<Vertex> visited = new HashSet<>();
        
        // Add the start vertex (vertex with index 0) to the visited set
        Vertex start= graph.getVertex(0);
        visited.add(start);
        
        
        // Iterate over the adjacent edges of the start vertex, adding them to the heap and SmallestEdge map
        for (Edge edge : start.getAdjList()) {
            minHeap.insert(edge);
            SmallestEdge.put(edge.getDestination(), edge);
        }
        
        
        while (minHeap.size()>0) {
            // Extract the minimum edge from the heap
            Edge minEdge = minHeap.extractMin();
            
            
            // Check if the destination vertex already been visited; skip this iteration
            if (visited.contains(minEdge.getDestination())) {
                continue;
            }
           
            MSTResultList.add(minEdge); // Add the minimum edge to the MST result list 
            visited.add(minEdge.getDestination()); //mark its destination vertex as visited

            
             // Iterate over the adjacent edges of the destination vertex of the minimum edge
             //updating the cheapestEdge map and adding edges to the heap
            for (Edge edge : minEdge.getDestination().getAdjList()) {
                

                if (!visited.contains(edge.getDestination()) && 
                        (SmallestEdge.get(edge.getDestination()) == null ||
                        edge.getWeight() < SmallestEdge.get(edge.getDestination()).getWeight())) {
                    SmallestEdge.put(edge.getDestination(), edge);
                    minHeap.insert(edge);
                }
            }
        }
        
        // Calculate the total weight of the MST by summing the weights
       for (Edge edge : MSTResultList) {
            totalWeight += edge.getWeight();
        }
    }

    public int getTotalWeight() {
        return totalWeight;
    }
    

    @Override
    public void displayResultingMST() {
        

        System.out.println("The minimum spanning tree generated by Prim's algorithm using a MinHeap is:\n");

        for (Edge edge : MSTResultList) {
            edge.displayInfo();
            
        }

        System.out.println("\nThe cost of the minimum spanning tree is: " + totalWeight);
        
}
}
    

